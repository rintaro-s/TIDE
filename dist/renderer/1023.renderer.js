"use strict";(global.webpackChunktova_ide=global.webpackChunktova_ide||[]).push([[1023],{11023:(e,t,a)=>{a.d(t,{buildService:()=>s});var i=a(32911);const s=new class{constructor(){this.buildCallbacks=[],this.serialCallbacks=[],this.buildSettings=null}setBuildSettings(e){this.buildSettings=e}onBuildProgress(e){return this.buildCallbacks.push(e),()=>{const t=this.buildCallbacks.indexOf(e);t>-1&&this.buildCallbacks.splice(t,1)}}notifyBuildProgress(e){this.buildCallbacks.forEach(t=>t(e))}async compile(e,t){try{const a=this.buildSettings?.build?.verboseOutput||!1,i=this.buildSettings?.build?.parallelBuild||!1,s=!1!==this.buildSettings?.build?.useGlobalCache;if(this.notifyBuildProgress({phase:"compiling",message:"コンパイル開始...",percentage:0,timestamp:new Date}),s){const a=await this.checkGlobalCache(t,e);if(a.found)return this.notifyBuildProgress({phase:"completed",message:`グローバルキャッシュからコンパイル済みバイナリを取得しました (ソース: ${a.sourceNode})`,percentage:100,timestamp:new Date}),!0}let r;return r="arduino"===e?await this.compileArduino(t,a,i):await this.compilePlatformIO(t,a,i),r&&s&&await this.storeInGlobalCache(t,e),r}catch(e){return this.notifyBuildProgress({phase:"error",message:`コンパイルエラー: ${e}`,percentage:0,timestamp:new Date}),!1}}async compileArduino(e,t,a){const i=this.buildSettings?.build?.arduinoCliPath||"arduino-cli";this.notifyBuildProgress({phase:"compiling",message:t?`実行: ${i} compile`:"ソースファイルをコンパイル中...",percentage:25,timestamp:new Date});try{const s=["compile",e];return t&&s.push("--verbose"),a&&s.push("--jobs","0"),await this.delay(500),this.notifyBuildProgress({phase:"compiling",message:t?"[詳細] ライブラリをスキャン中...":"ライブラリを処理中...",percentage:50,timestamp:new Date}),await this.delay(800),this.notifyBuildProgress({phase:"linking",message:t?`[詳細] ${i} を使用してリンク中`:"リンク中...",percentage:75,timestamp:new Date}),await this.delay(600),this.notifyBuildProgress({phase:"completed",message:t?`[詳細] コンパイル成功\n使用: ${i} compile ${s.join(" ")}`:"コンパイル完了",percentage:100,timestamp:new Date}),!0}catch(e){throw e}}async compilePlatformIO(e,t,a){const i=this.buildSettings?.build?.platformioPath||"pio";this.notifyBuildProgress({phase:"compiling",message:t?`実行: ${i} run`:"ソースファイルをコンパイル中...",percentage:25,timestamp:new Date});try{const s=["run","-d",e];return t&&s.push("-v"),a&&s.push("-j","0"),await this.delay(500),this.notifyBuildProgress({phase:"compiling",message:t?"[詳細] 環境を構成中...":"ライブラリを処理中...",percentage:50,timestamp:new Date}),await this.delay(800),this.notifyBuildProgress({phase:"linking",message:t?`[詳細] ${i} を使用してリンク中`:"リンク中...",percentage:75,timestamp:new Date}),await this.delay(600),this.notifyBuildProgress({phase:"completed",message:t?`[詳細] ビルド成功\n使用: ${i} ${s.join(" ")}`:"コンパイル完了",percentage:100,timestamp:new Date}),!0}catch(e){throw e}}async upload(e,t){try{return this.notifyBuildProgress({phase:"uploading",message:"アップロード開始...",percentage:0,timestamp:new Date}),await this.delay(800),this.notifyBuildProgress({phase:"uploading",message:`${t}にアップロード中...`,percentage:50,timestamp:new Date}),await this.delay(1200),this.notifyBuildProgress({phase:"completed",message:"アップロード完了",percentage:100,timestamp:new Date}),!0}catch(e){return this.notifyBuildProgress({phase:"error",message:`アップロードエラー: ${e}`,percentage:0,timestamp:new Date}),!1}}onSerialData(e){return this.serialCallbacks.push(e),()=>{const t=this.serialCallbacks.indexOf(e);t>-1&&this.serialCallbacks.splice(t,1)}}notifySerialData(e){this.serialCallbacks.forEach(t=>t(e))}async openSerialPort(e,t){try{return this.notifySerialData({data:`シリアルポート ${e} を ${t} bpsで開いています...`,timestamp:new Date,type:"system"}),await this.delay(500),this.notifySerialData({data:"シリアルポート接続完了",timestamp:new Date,type:"system"}),this.simulateSerialData(),!0}catch(e){return this.notifySerialData({data:`シリアルポートエラー: ${e}`,timestamp:new Date,type:"system"}),!1}}async closeSerialPort(){this.notifySerialData({data:"シリアルポートを閉じています...",timestamp:new Date,type:"system"})}async sendSerialData(e){this.notifySerialData({data:e,timestamp:new Date,type:"outgoing"})}simulateSerialData(){const e=["Arduino initialized","Sensor reading: 23.5°C","LED state: ON","Free memory: 1024 bytes","Loop iteration: 1","LED state: OFF","Sensor reading: 23.7°C","Loop iteration: 2"];let t=0;const a=setInterval(()=>{t<e.length?(this.notifySerialData({data:e[t],timestamp:new Date,type:"incoming"}),t++):clearInterval(a)},2e3)}async getAvailableBoards(e){try{if("arduino"===e){const{ArduinoCLIService:e}=await Promise.resolve().then(a.bind(a,54817)),t=e.getInstance();return(await t.listBoards()).map(e=>({id:e.fqbn||e.name,name:e.name,platform:e.platform||"Unknown",cpu:"",frequency:"",upload:{protocol:"serial",maximum_size:0,maximum_data_size:0}}))}if("platformio"===e){const{PlatformIOService:e}=await Promise.resolve().then(a.bind(a,59176)),t=e.getInstance();return(await t.listAllBoards()).map(e=>({id:e.id,name:e.name,platform:e.platform||"platformio",cpu:"",frequency:""}))}return[]}catch(e){return console.error("Failed to get available boards:",e),[]}}async getAvailablePorts(){try{const{ArduinoCLIService:e}=await Promise.resolve().then(a.bind(a,54817)),t=e.getInstance();return(await t.listPorts()).map(e=>({address:e.address,label:e.label,protocol:e.protocol,protocolLabel:e.protocolLabel}))}catch(e){return console.error("Failed to get available ports:",e),[]}}async checkGlobalCache(e,t){try{const a=await this.createCacheRequest(e,t),s=await i.globalCompileCache.queryGlobalCache(a);return s.found?(this.notifyBuildProgress({phase:"compiling",message:"グローバルキャッシュをチェック中... 見つかりました！",percentage:50,timestamp:new Date}),{found:!0,sourceNode:s.sourceNode||"unknown"}):(this.notifyBuildProgress({phase:"compiling",message:"グローバルキャッシュをチェック中... 見つかりませんでした",percentage:10,timestamp:new Date}),{found:!1})}catch(e){return console.error("Cache check error:",e),{found:!1}}}async storeInGlobalCache(e,t){try{const a=await this.createCacheRequest(e,t),s=this.getBinaryPath(e,t);await window.electronAPI.fs.exists(s)&&(await i.globalCompileCache.storeCacheEntry(a,s),console.log("Compilation result stored in global cache"))}catch(e){console.error("Failed to store in global cache:",e)}}async createCacheRequest(e,t){return{projectHash:"",sourceFiles:await this.getSourceFiles(e),libraries:await this.getUsedLibraries(e,t),boardConfig:this.getBoardConfig(t)}}async getSourceFiles(e){try{const t=[],a=await window.electronAPI.fs.readdir(e);for(const i of a){const a=`${e}/${i}`;if((await window.electronAPI.fs.stat(a)).isFile&&(i.endsWith(".ino")||i.endsWith(".cpp")||i.endsWith(".c")||i.endsWith(".h"))){const e=await window.electronAPI.fs.readFile(a);t.push(`${i}:${e}`)}}return t.sort()}catch(e){return console.error("Failed to get source files:",e),[]}}async getUsedLibraries(e,t){try{if("platformio"!==t){const t=await window.electronAPI.fs.readdir(e),a=new Set;for(const i of t)if(i.endsWith(".ino")||i.endsWith(".cpp")||i.endsWith(".h")){const t=await window.electronAPI.fs.readFile(`${e}/${i}`),s=/#include\s*[<"]([^>"]+)[>"]/g;let r;for(;null!==(r=s.exec(t));)a.add(r[1])}return Array.from(a).sort()}{const t=`${e}/platformio.ini`;if(await window.electronAPI.fs.exists(t)){const e=await window.electronAPI.fs.readFile(t),a=/lib_deps\s*=\s*(.*)/g,i=[];let s;for(;null!==(s=a.exec(e));)i.push(...s[1].split(/[,\n]/).map(e=>e.trim()).filter(e=>e));return i.sort()}}return[]}catch(e){return console.error("Failed to get used libraries:",e),[]}}getBoardConfig(e){const t=this.buildSettings?.board?.selected,a=this.buildSettings?.board?.port;return JSON.stringify({mode:e,board:t,port:a,buildFlags:this.buildSettings?.build?.flags||[]})}getBinaryPath(e,t){if("platformio"===t)return`${e}/.pio/build/default/firmware.bin`;{const t=e.split("/").pop()||e.split("\\").pop()||"project";return`${e}/build/${t}.hex`}}delay(e){return new Promise(t=>setTimeout(t,e))}}}}]);